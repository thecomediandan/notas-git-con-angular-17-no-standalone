<section class="container px-3">

    <article id="container-git-configuration">

        <h2><i [innerHTML]="getIcono('gear')"></i>&nbsp;Configuraciones</h2>

        <h3 id="git-version">git --version</h3>
        <p>
            Para consultar que versión de Git tenemos instalado podemos usar el comando <i>git --version o git -v</i>.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git --version
// O también
git -v</code></pre>

        <h3 id="git-init">git init</h3>
        <p>
            Para iniciar un repositorio <b>git</b> utilizamos el código <i>git init</i> el cual nos habilita el directorio donde estamos como un repositorio local donde podremos hacer seguimiento de los cambios realizados en este ambiente.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git init</code></pre>

        <h3>git init --bare (Repositorio Local)</h3>
        <p>
            Generalmente recurriremos a un repositorio en la nube, pero en caso de que por alguna circunstancia necesitemos crear un entorno local para compartir un repositorio en una red local, esto se puede hacer gracias a la bandera <i>--bare</i> al momento de iniciar un repositorio con <i>git init</i>. Esta configuración nos creará un servidor local con todos los archivos de configuración necesarios, esta carpeta seleccionada no servirá para almacenar los archivos directamente porque es la que servirá de intermediario para la subida de los proyectos con otros usuarios. 
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git init --bare</code></pre>

        <h3 id="git-config">git config (credenciales)</h3>
        <p>
            Ahora tendríamos que configurar las credenciales con el cual nos identificaremos y registraremos al momento de realizar cambios al repositorio estas configuraciones las podemos modificar en <i>git config.</i>
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git config --global user.name "[tu_nombre]"
git config --global user.email "[tu_correo]"</code></pre>

        <p>
            Las configuraciones también pueden ser locales a nivel repositorio, de todo el sistema a nivel de todos los usuarios del sistema operativo además del global que implica a todo el control del usuario del sistema operativo en uso.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Nivel local
git config --local user.name "[tu_nombre]"
git config --local user.email "[tu_correo]"
// Nivel Global
git config --global user.name "[tu_nombre]"
git config --global user.email "[tu_correo]"
// Nivel Sistema
git config --system user.name "[tu_nombre]"
git config --system user.email "[tu_correo]"</code></pre>

        <p>
            Si quisieramos ver las configuraciones de usuario y email configurados en un repositorio, podemos usar las mismas instrucciones solo que omitiendo los valores de asignación.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Nivel local
git config --local user.name
git config --local user.email
// Nivel Global
git config --global user.name
git config --global user.email
// Nivel Sistema
git config --system user.name
git config --system user.email</code></pre>
        
        <h3>git config (autocrlf)</h3>
        <p>
            Tambien tendremos que tomar en cuenta el como el sistema operativo trata los saltos de línea, el cual es distinto en Linux y Windows, esto debido a que Windows maneja un símbolo oculto el cual no maneja Linux, no tomar en cuenta estos detalles puede causar errores al momento de desplegar las aplicaciones.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// En Windows
git config --global core.autocrlf true  
// En Linux
git config --global core.autocrlf input</code></pre>

        <h3>git config (alias)</h3>  
        <p>
            Habrá momentos en los que quisieramos acortar los comandos debido a que estos pueden ponerse muy largos de escribir y es necesario un atajo mas corto, para esto puede usarse los alias. Podremos poner a disposición en alias a diferentes niveles del repositorio (<i>--local, --global y --system</i>).
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Creación de alias
git config --local alias.[nombre_alias] "[comando_git]"
// Uso del alias
git [nombre_alias]

// Ejemplo: Para el uso de una configuracion de un log
// Comando git de ejemplo:
git log --oneline --all --graph --pretty=format:"%C(auto)%h%d %s %C(black)%(bold)%cr"
// Creación del alias en modo global
git config --global alias.log_pretty "git log --oneline --all --graph --pretty=format:'%C(auto)%h%d %s %C(black)%(bold)%cr'"
// Uso del alias
git log_pretty</code></pre>

        <h3>git config (lista)</h3>
        <p>
            Podemos visualizar todas las configuraciones del repositorio con el comando <i>git config --list</i>, el cual tambien puede ser utilizado con <i>--local, --global y --system</i>, dependiendo del ambiente a consultar.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git config --list
// Otras formas:
git config --local --list
git config --global --list
git config --system --list</code></pre>

        <h3 id="git-branch">git branch</h3>
        <p>
            Una cosa que debemos de configurar es la creación de ramas (branch), por defecto se nos crea una llamada <i>master</i> y nos encontramos posicionados en ella esto puede cambiar por convenciones diferentes por lo general se la suele renombrar por <i>main</i> el comando necesario para esto es <i>git branch</i>. En varios repositorios se suele manejar diferentes ramas para distintos propósitos para después al final unirlas en una sola y esta rama principal suele ser la llamada <i>main</i> la cual no es de uso general porque esta es solo para unir las demás ramas.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para ver las ramas del repositorio
git branch
// Para crear una rama
git branch [nombre_rama]
// Para renombrar una rama
git branch -M [nombre_rama]
// Para eliminar una rama que no tiene conflictos
git branch -d [nombre_rama]
// Para forzar la eliminación de una rama
git branch -D [nombre_rama]</code></pre>
        
        <h3 id="gitignore">.gitignore</h3>
        <p>
            Después de iniciado el repositorio tendremos que configurar el archivo <i>.gitignore</i>, este archivo generalmente los FrameWorks los implementan automáticamente, pero en caso de que no, tendremos que configurarlo. Este archivo se encarga de ignorar archivos para la zona de confirmación a no ser que se especifiquen explícitamente. Este archivo generalmente se encuentra en la raíz del proyecto para Git lo detecte.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Este archivo puede ignorar directorios
carpeta/
// Contenido de carpetas
carpeta/*
//  Podemos excluir algunos archivos
!carpeta/archivo1.txt
// Agregar archivos expecíficos
archivo2.txt
// Archivos concretos
*.txt
*.pdf
achivo_?.txt
// Y otros comodines...</code></pre>

    </article>

    <article id="container-git-basic-operation">

        <h2><i [innerHTML]="getIcono('tasks')"></i>&nbsp;Operaciones básicas</h2>

        <h3 id="git-switch">git switch</h3>
        <p>
            También es importante la navegación entre ramas y en este caso existen dos maneras muy comunes, una manera muy conocida es usando <i>git checkout</i> pero este comando en realidad cubre otras necesidades por lo que deberíamos usar <i>git switch</i> para este propósito.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Operaciones con checkout
// Cambio de ramas
git checkout [nombre_rama]
// Para crear una rama y movernos en ella
git checkout -b [nombre_rama]
// Operaciones con switch
// Cambio de ramas
git switch [nombre_rama]
// Para crear una rama y movernos a ella
git switch -c [nombre_rama]</code></pre>

        <h3 id="git-status">git status</h3>
        <p>
            Para consultar el estado del repositorio en cualquier momento podemos usar el comando de <i>git status</i>. Los estados posibles de los archivos del repositorio son los de archivos nuevos creados, modificados, eliminados.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git status
// O también una versión resumida
git status -s
git status --short</code></pre>

        <h3 id="git-add">git add</h3>
        <p>
            Para poder agregar los archivos a la zona de preparación, podemos usar <i>git add</i>. Esto no guarda los archivos directamente pero los pone en un área donde estamos indicando que son los archivos vamos a confirmar.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para agregar todos
git add .
// O agregar determinados archivos
git add [ruta_archivo] ...
// Para normalizar errores de Final de Linea (CRLF)
git add --renormalize .
git add --renormalize [ruta_archivo] ...</code></pre>

        <h3 id="git-rm">git rm</h3>
        <p>
            Para poder eliminar archivo de la zona de preparación por alguna razón, podemos usar <i>git rm --cached</i>. No elimina el archivo pero si lo quita de la lista de archivos que serán confirmados.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para eliminar todos
git rm --cached .
// O agregar determinados archivos
git rm --cached [ruta_archivo] ...</code></pre>

        <p>
            En caso de querer eliminar los archivos tanto en la zona de preparación como fisicamente del almacenamiento local omitimos la bandera <i>--cached</i>.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para eliminar todos
git rm .
// O agregar determinados archivos
git rm [ruta_archivo] ...</code></pre>

        <h3 id="git-commit">git commit</h3>
        <p>
            Ahora para poder confirmar los cambios y estos se guarden en el repositorio tendremos que usar <i>git commit</i>. Esto confirma los archivos que estan en la zona de preparación.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para introducir comentarios mediante el IDE.
git commit
// O agregar los comentarios directamente
git commit -m "[mensaje/comentario]"</code></pre>

        <p>
            Si queremos confirmar directamente todos los archivos sin usar <i>git add</i> podemos usar una bandera que simplifica la instrucción.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para introducir comentarios mediante el IDE configurado
git commit -a
// O agregar los comentarios directamente
git commit -m "[mensaje/comentario]" -a</code></pre>

        <p>
            En caso de sobre escribir el comentario o mensaje del último commit o confirmación podemos usar <i>git commit --amend</i>
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para introducir comentarios mediante el IDE configurado
git commit --amend
// O agregar los comentarios directamente
git commit --amend -m "[mensaje/comentario]"</code></pre>

        <h3 id="git-reset">git reset</h3>
        <p>
            En caso de la necesidad de deshacer commits, estos tienen una regla para ignorar los commits y es que se deshacerán los commits superior a la posición del puntero HEAD que indica la posición actual del ultimo commit o commit actual posicionado. Esto se puede indicar mediante el comando <i>git reset</i>. El comando tiene 3 tipos de tratamiento mas comunes para el reestablecimiento de un commit, que son: <i>--soft, --mixed y --hard</i>. <i>--soft</i> "elimina" los commits arriba del commit seleccionado mediante el puntero HEAD y los mueve al área de preparación restaurando los cambios realizados en el commit seleccionado. <i>--mixed</i> "elimina" los commits arriba del commit seleccionado mediante el puntero HEAD y no los mueve al área de preparación pero si aparecen modificados y listos para ser agregados al zona de preparación restaurando los cambios realizados en el commit seleccionado. <i>--hard</i> "elimina" los commits arriba del commit seleccionado mediante el puntero HEAD (<b>puede ser HEAD, HEAD~1, HEAD~2, ... Que indica las posiciones con base al puntero HEAD</b>, en todos los casos) y no los mueve al área de preparación ni aparecen modificados, son descartados en su totalidad restaurando los cambios realizados en el commit seleccionado.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git reset --soft [hash_commit o HEAD~(Número correspondiente al commit partiendo del ultimo como HEAD)]
git reset --mixed [hash_commit o HEAD~(Número correspondiente al commit partiendo del ultimo como HEAD)]
git reset --hard [hash_commit o HEAD~(Número correspondiente al commit partiendo del ultimo como HEAD)]</code></pre>

        <h3 id="git-reflog">git reflog</h3>
        <p>
            En realidad las referencias a los commits no se eliminan solo se ignoran, eso abre la posibilidad de recuperar commits deshechos y se puede recuperar con la ayuda de los comandos <i>git reflog</i> y <i>git reset</i>. <i>git reflog</i> para recuperar la referencia hash del commit y restaurarlo con lo aprendido con <i>git reset [bandera] [hash_commit]</i>.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Todas las referencias de todas las ramas
git reflog
// Todas las referencias de una rama en especifico
git reflog [nombre_rama]
// Limpiar el reflog y entradas antiguas
git reflog expire</code></pre>

        <h3 id="git-checkout">git checkout</h3>
        <p>
            Si se trata de recuperar el ultimo commit de un archivo, todos o archivos específicos esto se puede gracias al comando <i>git checkout</i>. Con este comando recuperamos el estado de los archivos a los que estaban en el último commit realizado. Pero tambien puede ser usado para moverse entre los commits mediante sus hash (consultar <i>git log</i>), crear ramas, crear ramas con un commit es específico (puede incluir nombres de tags, consultar <i>git tag</i>).
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Todos lo archivos, tomar en cuenta que no todos los archivos pueden pertencer al mismo commit
git checkout .
// Archivos específicos
git checkout [archivo(s)] [...]
// Crear rama y moverse a ella
git checkout -b [nombre_rama]
// Crear rama con un commit o tag en específico
git checkout -b [nombre_rama] [hash del commit o nombre de tag]</code></pre>   

        <h3 id="git-log">git log</h3>
        <p>
            Si queremos ver los históricos de los <i>commits</i> podemos usar <i>git log</i>. Hay diversas maneras de ver los históricos con distintas banderas incluso configuraciones de externos en internet (<a href="http://devhints.io/git-log" target="_blank">devhints.io/git-log</a>) que encuentran diversas configuraciones dependendiendo las necesidades para mostrar el historial de cambios en el repositorio.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para ver todos los cambios con su respectivo hash versión estandar
git log
// Mostrar los n-ultimos commits
git log -n [número de los últimos commit a mostrar]
// Versión resumida
git log --oneline
// Versión detallada
git log -p
// Versión gráfica usualmente usado en casos de "merge"
git log --graph
// Con configuraciones externas
git log --pretty="format:%h %s %ae"</code></pre>

        <p class="note">
            En realidad las referencias a los commits no se eliminan solo se ignoran, eso abre la posibilidad de recuperar commits deshechos y se puede recuperar con la ayuda de los comandos <i>git reflog</i> y <i>git reset</i>. <i>git reflog</i> para recuperar la referencia hash del commit y restaurarlo con lo aprendido con <i>git reset [bandera] [hash_commit]</i>.
        </p>

        <h3 id="git-remote">git remote</h3>
        <p>
            Para conectar con un servidor sea local o remoto (por internet o nube) tendremos que conectar esta relacion entre nuestro repositorio local con el remoto mediante <i>git remote</i>. Esto se usa para poder guardar el historico de nuestros commits y compartirlos con los usuarios que tengan acceso a este servidor sea local o remoto.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para ver los nombres de los servidores
git remote
// Ver mas específico los servidores
git remote -v
// Para agregar un servidor remoto
git remote add [nombre (generalmente origin)] [link SSH o HTTPS]
// Para agregar un servidor local
git remote add [nombre (generalmente origin)] [dirección de la carpeta]
// Para renombrar el nombre del servidor
git remote rename [nombre_actual (generalmente origin)] [nuevo_nombre]
// Para cambiar la dirección del servidor
git remote set-url [nombre_servidor] [nueva dirección local o remota]</code></pre>

        <h3 id="git-clone">git clone</h3>
        <p>
            Para poder clonar o traer un repositorio remoto el que usualmente es compartido mediante una URL de conexión HTTPS o SSH, utilizamos el comando <i>git clone</i>. Esto trae todo un proyecto donde nos brinden una dirección para poder clonarlo y trabajar sobre el. Si no se especifica un directorio donde deseamos se haga la descarga por defecto esta se realiza donde se esta ubicado (./). Por defecto al clonar un repositorio se configura el servidor remoto llamado <i>origin</i>.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para clonar un proyecto en su rama principal
git clone [url HTTPS o SSH] [*directorio donde deseamos haga la descarga]
// Para clonar un proyecto indicando que rama del proyecto queremos descargar
git clone --branch [nombre_rama] [url HTTPS o SSH] [*directorio donde deseamos haga la descarga]</code></pre>

        <h3 id="git-push">git push</h3>
        <p>
            Para poder guardar los cambios confirmados ("commiteados") de los archivos de nuestro proyecto en un servidor sea local o remoto podemos usar el comando <i>git push</i>. Esto subirá el historial de cambios de los archivos confirmados.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para poder guardar por defecto el servidor --set-upstream y usar solo "git push" posteriormente
git push -u [nombre_servidor] [nombre_rama]
// Si se guardo por defecto el nombre del servidor y rama
git push
// Para forzar un push, generalmente no se usa porque puede compremeter el proyecto
git push --force [nombre_servidor] [nombre_rama]</code></pre>

        <h3 id="git-pull">git pull</h3>
        <p>
            Para poder traer los cambios de un servidor local o remoto podemos usar el comando <i>git pull</i>. Esto trae todos los cambios realizados en la ultima confirmación junto con el historial de cambios confirmados.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Si se habilito en algun momento --set-upstream o sis se configuro el nombre del servidor o rama por defecto
git pull
// En caso de ser mas específicos sin haber una configuración por defecto
git pull [nombre_servidor] [nombre_rama]</code></pre>

    </article> 

    <article id="container-git-practice-cases">

        <h2><i [innerHTML]="getIcono('paperclip')"></i>&nbsp;Casos prácticos</h2>

        <h3 id="git-stash">git stash</h3>
        <p>
            Habrá momentos en el que necesitemos guardar nuestros cambios momentaneamente en algún lugar, por diversas razones, como por ejemplo guardarlo para conservar algunos cambios para posteriormente hacer un <i>git pull</i> y despues usar <i>git stash</i> con sus banderas correspondientes de recuperación del último cambio realizado o algún otro que fue almacenado en esta zona de apilado para asi mantener actualizado el repositorio con algunos cambios a conservar.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Si queremos guardar los cambios no confirmados a la lista de stashes
git stash
// Si queremos guardar los cambios no confirmados a la lista de stashes con un nombre
git stash push -m "nombre_stash"
// Si queremos listar todos los cambios guardados en la pila
git stash list
// Si queremos recuperar los últimos cambios en la pila y eliminarlo de la lista
git stash pop
// Si queremos recuperar cambios específicos en la pila y eliminarlo de la lista
git stash pop stash&commat;&lcub;[número de cambio en la lista stash, 0 es el último cambio]&rcub;
// Si solo queremos eliminar el ultimo cambio guaradado en la pila de stash
git stash drop
// Si queremos eliminar un cambio específico de la pila
git stash drop stash&commat;&lcub;[número de cambio en la lista stash, 0 es el último cambio]&rcub;
// Si queremos restaurar los últimos cambios sin eliminarlo de la lista
git stash apply 
// Si queremos restaurar cambios específicos de la lista stash sin eliminarlo de la lista
git stash apply stash&commat;&lcub;[número de cambio en la lista stash, 0 es el último cambio]&rcub;</code></pre>

        <h3 id="git-merge">git merge</h3>
        <p>
            Si por alguna razón queremos unir ramas que en un caso particular y muy común puede ser que queramos traer los cambios de otra rama a la rama <i>main</i> para tener cambios sincronizados en la rama <i>main</i> con los cambios de otra rama, entonces pdoemos usar el comando <i>git merge</i>. Para poder usarlo y tomando el ejemplo mencionado, tendremos que posicionarnos en la rama que queremos que se le adicione los cambios de la otra rama. En algunos casos suele haber conflictos con el <i>merge</i>, Git nos da la posibilidad de resolverlos para continuar con la fusión. Para ver los cambios bajo el efecto de esta fusión podemos ayudarnos del comando <i>git log --graph</i> y podremos notar que los commits de ambas ramas se mantienen y se notan bifurcadas de la unión.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git merge [nombre_otra_rama]
// En caso de haber solucionado conflictos "merge"
git merge --continue</code></pre>

        <h3 id="git-rebase">git rebase</h3>
        <p>
            Si queremos una fusión en el que se note el historial de commits limpia de manera lineal y no bifurcada como en el caso del uso del comando <i>git merge</i> podemos usar el comando <i>git rebase</i>. Este comando hace lo mismo que el comando <i>merge</i> con la difernecia de mantener un orden lineal en el historial de commits, esto porque aplica cada uno de los commits de la rama rebaseada en la del destino.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git rebase [nombre_otra_rama]
// En caso de haber solucionado conflictos "rebase"
git rebase --continue</code></pre>

        <h3 id="git-restore">git restore</h3>
        <p>
            Puede haber situaciones en las que queramos deshacer cambios en los archivos en el proyecto que se encuentren modificados o en el estado de preparación (utilizando <i>git add</i>) para esto se usa este comando <i>git restore</i>.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Todos los archivos modificados
git restore .
// Archivos modificados específicos
git restore [nombre_archivo] [...]
// Todos los archivos en el área de preparación
git restore --staged .
// Archivos específicos en el área de preparación
git restore --staged [nombre_archivo] [...]</code></pre>

        <h3 id="git-revert">git revert</h3>
        <p>
            Puede tomarse como la continuación de casos del comando <i>git restore</i> en el caso en el que quiseramos aplicar un commit anterior o un cambio al que quisieramos retornar, en este caso podemos usar el comando <i>git revert</i>. No confundir con el uso que tiene <i>git reset</i> que mueve el puntero HEAD al commit especificado, en cambio <i>git revert</i> crea un nuevo commit deshaciendo los cambios actuales y aplicando los cambios del commit especificado (Se usa el código hash del commit, puede consultar <i>git log</i>).
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Deshace los cambios del último commit
git revert
// Deshace los cambios del commit especificado
// Nos pedirá introducir comentarios para el nuevo commit (salir del editor con ":x")
git revert [codigo_hash]</code></pre>

        <h3 id="git-diff">git diff</h3>  
        <p>
            En caso de que quisieramos visualizar distintas diferencias entre commits podemos usar el comando <i>git diff</i>. Para usarlo correctamente como primer commit introducido este debe ser anterior al segundo en terminos de tiempo. <b>Las rutas de los commit no solo pueden ser los hashes de los commits tambien podriamos usar la nomenclatura con el puntero (HEAD, HEAD~1, HEAD~2, ...).</b>
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para ver los cambios realizados especificamente del ultimo commit
git diff
// Para comparar el commit especificado con el actual
git diff [hash_especificado]
// Versión detallada
git diff [hash_commit_anterior] [hash_commit_posterior]
// Versión que solo muestra los nombres de archivos con diferencias
git diff --name-only [hash_commit_anterior] [hash_commit_posterior]
// Versión que solo muestra las lineas y palabras con diferencias
git diff --word-diff [hash_commit_anterior] [hash_commit_posterior]</code></pre>

        <h3 id="git-tag">git tag</h3>  
        <p>
            Puede ser muy necesario manejar versiones de nuestros proyectos de manera literal para esto podemos usar el comnado <i>git tag</i>. Generamos una versión que es de valor para producción indicando que tenemos una versión funcional, que no es mas que tener un nombre para un commit en específico por ejemplo lo mas usual "v0.1.0". Para llenar el <i>tag</i> con un commit, tendremos que enviarlo através de <i>git push</i>.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Para ver la lista de tags
git tag
// Para crear un tag
git tag -a [nombre_tag_version] -m "[mensaje/comentario del tag o version]"
// Para enviar los cambios al tag
git push [nombre_rama] [nombre_tag_version]</code></pre>

        <h3 id="git-fetch">git fetch</h3>  
        <p>
            En caso de querer ver que cambios traería si quisieramos hacer un <i>git pull</i> a un repositorio para traer cambios, podriamos ver esta posibilidad con el comando <i>git fetch</i>. Este comando no realiza cambios al repositorio local, pero nos mostrará como afectaría este cambio en el repositorio.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">// Si tenemos configurado el servidor y rama por defecto con --set-upstream
git fetch
// Fetch específico y completo
git fetch [nombre_servidor] [nombre_rama]</code></pre>

        <h3 id="git-switch-detach">git switch (rama virtual)</h3>  
        <p>
            En caso de que quisieramos probar una rama de un repositorio para ejecutar pruebas u otra necesidad podríamos crear una rama virtual de esa rama con <i>git switch</i> con su bandera <i>--detach</i>. Todo cambio realizado en esta rama no se guardará a no ser que se cree una rama para guardar los cambios.
        </p>
        <pre class="prettyprint rounded-3 d-inline-block p-3"><code class="code">git switch --detach [nombre_servidor]/[nombre_rama]</code></pre>

    </article>

</section>